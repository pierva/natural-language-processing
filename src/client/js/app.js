/**
 * This is the main js file for the entire application.
 * The library generated by webpack is called Client
 * The application is initiated by calling octo.init()
*/

/**
* The model holds all the front end static data
*/
const model = {
    domains: ['restaurants', 'hotels', 'cars', 'airlines']
}

/**
 * octo short for octopus is in charge of connecting the view to the 
 * model. In particular will handle all the interaction between 
 * DOM elements and backend API.
*/
const octo = {
    init: () => {
        view.init()
    },

    getDomains: () => {
        return model.domains
    }
}

/**
 * The view object contains all the functions  
 * 
*/
const view = {
    init: () => {
        // Wait until the DOM is fully loaded before initializing the view
        document.addEventListener('DOMContentLoaded', () => {
            view.eventHandlers();
            view.initializeSelects(document.querySelector('#domain'),
                octo.getDomains())
        })
    },

    createList: (items) => {
        const ul = document.createElement('ul')
        for (let item of items) {
            const li = document.createElement('li')
            li.text = item
            ul.innerHTML = li
        }
        return ul
    },

    handleError: (message) => {
        const feedback = document.querySelector("#feedback")
        feedback.classList.add('error')
        feedback.textContent = message
        feedback.style.opacity = '1'
        setTimeout(() => {
            feedback.style.opacity = '0'
        }, 3000)
    },

    renderReviewResults: (data) => {
        const container = document.querySelector('#reviewResults .container')
        container.innerHTML = '<h3 class="result-header">Processed review aspects with confidence in %.'
        const groupDiv = document.createElement('div')
        groupDiv.classList.add('result-items')
        data.aspects.forEach((aspect) => {
            const div = document.createElement('div')
            div.classList.add('item-group')
            div.innerHTML = `
            <span class="label">Aspect</span>
            <span class="item">${aspect.aspect}</span>
            <span class="label">Confidence</span>
            <span class="item">${(aspect.aspect_confidence*100).toFixed(2)}%</span>
            <br>
            <span class="label">Polarity</span>
            <span class="item">${aspect.polarity}</span>
            <span class="label">Confidence</span>
            <span class="item">${(aspect.polarity_confidence*100).toFixed(2)}%</span>`
            groupDiv.appendChild(div)
        })
        container.appendChild(groupDiv)
    },

    updateDOM: (data) => {
        if (data.error) {
            view.handleError(data.error)
            return
        }
        const container = document.querySelector('#textResults .container')
        let index
        data.results.forEach((result, idx) => {
            if(result.endpoint === 'summarize') index = idx
            else {
                container.innerHTML = 
                    `<h3 class="result-header">${result.endpoint}</h3>
                    <div class="result-items">
                        <div class="item-group">
                            <span class="label">Polarity</span>
                            <span class="item">${result.result.polarity}</span>
                        </div>
                        <div class="item-group">
                            <span class="label">Polarity Confidence</span>
                            <span class="item">
                                ${(result.result.polarity_confidence*100).toFixed(2)}
                            </span>
                        </div>
                        <div class="item-group">
                            <span class="label">Subjectivity</span>
                            <span class="item">${result.result.subjectivity}</span>
                        </div>
                        <div class="item-group">
                            <span class="label">Subjectivity Confidence</span>
                            <span class="item">
                                ${(result.result.subjectivity_confidence*100).toFixed(2)}
                            </span>
                        </div>
                    </div>
                    <hr>
                    `
            }
        })

        // This solution has been implemented to avoid nested loops
        if(index) {
            const header = document.createElement('h3')
            header.classList.add('result-header')
            header.textContent = data.results[index].endpoint
            const ul = document.createElement('ul')
            ul.classList.add('p-1')
            data.results[index].result.sentences.forEach((sentence) => {
                const li = document.createElement('li')
                li.classList.add('list-item')
                li.textContent = sentence
                ul.appendChild(li)
            })
            container.appendChild(header)
            container.appendChild(ul)
        }
        
        return true
    },

    /**
     * @param {DOMElement} elem Select element where to append the options
     * @param {array} options List of options to append to the parent DOMElement
     */
    initializeSelects: (elem, options) => {
        options.forEach(domain => {
            const option = document.createElement('option')
            option.setAttribute('name', domain)
            option.text = domain
            elem.appendChild(option)
        });
    },

    eventHandlers: () => {
        const textForm = document.querySelector('#textForm')
        const reviewForm = document.querySelector('#reviewForm')
        textForm.addEventListener('submit', (event) => {
            event.preventDefault();
            Client.handleSubmit('combined', textForm.children[0])
                .then((data) => {
                    view.updateDOM(data);
                })
        })
        reviewForm.addEventListener('submit', (event) => {
            event.preventDefault()
            const reviewTextArea = document.querySelector('#reviewArea')
            const elem = document.querySelector('#domain')
            const domain = elem.options[elem.selectedIndex].getAttribute('name')
            Client.handleSubmit('review', reviewTextArea, domain)
                .then((data) => {
                    view.renderReviewResults(data);
                })
        })
    }
}


// Iinitiate the application
export { octo }