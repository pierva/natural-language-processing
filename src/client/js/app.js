/**
 * This is the main js file for the entire application.
 * The library generated by webpack is called Client
 * The application is initiated by calling octo.init()
*/

/**
* The model holds all the front end static data
*/
const model = {
    domains: ['restaurants', 'hotels', 'cars', 'airlines']
}

/**
 * octo short for octopus is in charge of connecting the view to the 
 * model. In particular will handle all the interaction between 
 * DOM elements and backend API.
*/
const octo = {
    init: () => {
        view.init()
    },

    getDomains: () => {
        return model.domains
    }
}

/**
 * The view object contains all the functions  
 * 
*/
const view = {
    init: () => {
        // Wait until the DOM is fully loaded before initializing the view
        document.addEventListener('DOMContentLoaded', () => {
            view.eventHandlers();
            view.initializeSelects(document.querySelector('#domain'),
                octo.getDomains())
        })
    },

    createList: (items) => {
        const ul = document.createElement('ul')
        for (let item of items) {
            const li = document.createElement('li')
            li.text = item
            ul.innerHTML = li
        }
        return ul
    },

    updateDOM: (data) => {
        // Expected 3 arrays
        console.log(data)
        const resultDiv = document.querySelector('.result-items')
        // Reset the content
        resultDiv.innerHTML = ''
        let index
        data.results.forEach((result, idx) => {
            if(result.endpoint === 'summarize') index = idx
            else {
                resultDiv.innerHTML = 
                    `<div class="item-group">
                        <span class="label">Polarity</span>
                        <span class="item">${result.result.polarity}</span>
                    </div>
                    <div class="item-group">
                        <span class="label">Polarity Confidenxe</span>
                        <span class="item">${result.result.polarity_confidence}</span>
                    </div>
                    <div class="item-group">
                        <span class="label">Subjectivity</span>
                        <span class="item">${result.result.subjectivity}</span>
                    </div>
                    <div class="item-group">
                        <span class="label">Subjectivity Confidence</span>
                        <span class="item">${result.result.subjectivity_confidence}</span>
                    </div>
                    `
            }
        })
        
        return true
    },

    /**
     * @param {DOMElement} elem Select element where to append the options
     * @param {array} options List of options to append to the parent DOMElement
     */
    initializeSelects: (elem, options) => {
        options.forEach(domain => {
            const option = document.createElement('option')
            option.setAttribute('name', domain)
            option.text = domain
            elem.appendChild(option)
        });
    },

    eventHandlers: () => {
        const textForm = document.querySelector('#textForm')
        const reviewForm = document.querySelector('#reviewForm')
        textForm.addEventListener('submit', (event) => {
            event.preventDefault();
            Client.handleSubmit('combined', textForm.children[0])
                .then((data) => {
                    view.updateDOM(data);
                })
        })
        reviewForm.addEventListener('submit', (event) => {
            event.preventDefault()
            const reviewTextArea = document.querySelector('#reviewArea')
            const elem = document.querySelector('#domain')
            const domain = elem.options[elem.selectedIndex].getAttribute('name')
            Client.handleSubmit('review', reviewTextArea, domain)
                .then((data) => {
                    view.updateDOM(data);
                })
        })
    }
}


// Iinitiate the application
export { octo }